TODO
====

This file tracks the current development status and planned work.

# try/finally

- **Normal path**: try body → goto after_handlers → (else) → finally. Working.
- **Exception path (single try/finally)**: catch-all runs finally then rethrows; stackmap uses `java/lang/Throwable` for catch_type 0; restore + `stackmap_set_locals_count` before marking after_handlers so frame has correct locals; jump + frame before catch-all so fall-through does not merge 0 stack with handler’s 1 stack.
- **Nested try/finally**: verifier still reports "stack size doesn't match" at inner catch-all (merge of 0 and 1 stack). Possible fix: ensure inner catch-all and inner after_handlers never share the same bytecode offset, or refine stackmap merge logic for exception handlers.

## Edge cases

- **try/finally only** (no except): catch-all is the only handler; normal path goes try → goto after_handlers → finally → done; exception path goes catch_all → finally → rethrow. Correct.
- **try/except/finally**: uncaught exception → catch_all → finally → rethrow. Caught exception → handler → goto after_handlers → finally (normal path). Correct.

FUTURE CONSIDERATIONS
---------------------

[ ] Optimizations
    - Specialized bytecode for common patterns
    - Type inference for local variables
    - Inline caching warmup
    - Dead code elimination

[ ] **IMPORTANT: Native JVM class generation for Python classes**
    Currently all Python classes use runtime $Cls/$Inst objects with dictionary-based
    method lookup. This is flexible (supports multiple inheritance, dynamic modification)
    but slower than native JVM dispatch.
    
    For single-inheritance classes without metaclasses, we could generate actual JVM
    classes where Child extends Parent. This would give:
    - Native JVM method dispatch (significantly faster)
    - JVM JIT optimization of method calls
    - Better integration with Java code
    
    Implementation approach:
    - Detect single-inheritance, no-metaclass classes at compile time
    - Generate a real JVM class (using ClassWriter) for each Python class
    - Map __init__ to constructor, methods to instance methods
    - Instance attributes could use a backing $D or individual fields
    - Fall back to $Cls/$Inst for multiple inheritance or dynamic cases
    
    This is how Jython achieves reasonable performance. Consider prioritizing this
    optimization once the core language features are complete.

[ ] Python compatibility - remaining features
    - [x] __slots__ - implemented with array-based storage
          Classes with __slots__ use array instead of dict for instance attrs
          Invalid attribute assignment raises AttributeError
    - Metaclasses
    - [x] Multiple inheritance with C3 MRO
          MRO computed at class creation using C3 linearization algorithm
          Attribute lookup walks MRO instead of depth-first bases
          Inconsistent MRO (e.g., class C(A, B) where B extends A) raises TypeError
    
[x] Python compatibility - implemented
    - Descriptors (property, classmethod, staticmethod) - see line 317
    - __getattr__/__setattr__/__delattr__ - in $O, $Inst, etc.
    - Context managers (__enter__/__exit__) - see line 207
    - Iterators and generators (yield, yield from) - see line 153, 309
    - Async/await with virtual threads ($Async.java, $Future.java)
      * Uses Java 21 virtual threads for true concurrency
      * gather(), sleep(), run() for asyncio-like API
      * Virtual threads yield carrier threads on blocking
    - Match/case structural pattern matching - literals, captures, or, guards, sequences

[ ] Java interop
    - Calling Java methods from Python
    - Implementing Java interfaces
    - Java collection wrappers
    - Exception bridging

[ ] Tooling
    - [x] Source maps for debugging - LineNumberTable now generated
          Stack traces show Python file and line numbers
    - REPL
    - Package manager integration

