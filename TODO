LORETTA TODO
============

This file tracks the current development status and planned work.


COMPLETED
---------

[x] Lexer (lexer.c)
    - Feedforward style tokenizer
    - Python indentation handling (INDENT/DEDENT tokens)
    - Implicit line continuation inside (), [], {}
    - All Python 3 token types
    - String literals with escape sequences
    - Numeric literals (int, float, hex, octal, binary, imaginary)
    - Keywords and soft keywords (match, case, type)

[x] Parser skeleton (parser.c)
    - Recursive descent parser
    - AST node types matching Python's official AST spec
    - Basic statement parsing (def, class, if, while, for, import, etc.)
    - Binary operator precedence via Pratt parsing
    - Comparison chains (a < b < c)
    - Boolean operators (and, or) with correct precedence
    - All comparison operators including is/is not/in/not in
    - Conditional expressions (x if cond else y)
    - Lambda expressions (lambda x, y: x + y)
    - Augmented assignment (+=, -=, *=, etc.)
    - Chained assignment (a = b = c = value)
    - Slice parsing (a[1:2:3], a[:], a[::2], etc.)
    - List/set/dict/generator comprehensions with multiple for/if clauses
    - Set literals ({1, 2, 3})
    - Tuple literals ((1, 2, 3))
    - Function arguments (positional, keyword, defaults, *args, **kwargs)
    - Decorators (@decorator, @decorator(args))
    - Starred expressions in calls (*args, **kwargs)
    - Keyword arguments in calls (name=value)
    - Yield and yield from expressions
    - Await expressions
    - Async function definitions
    - Walrus operator (:=)
    - Class definitions with base classes
    - try/except/finally statements with multiple handlers
    - with statements (context managers)
    - raise statements (with optional from clause)
    - assert statements
    - del statements
    - global and nonlocal declarations
    - Tuple unpacking in assignments (a, b = pair)
    - Starred expressions in unpacking (*rest, a = items)
    - Match/case statements (Python 3.10+ structural pattern matching)
    - Pattern types: literals, captures, wildcards, sequences, mappings, classes, or, as
    - f-strings parsed as strings (full interpolation would require lexer changes)

[x] Semantic analyzer skeleton (analyze.c)
    - Scope and symbol table construction
    - Basic name resolution
    - Symbol kinds (variable, parameter, function, class, global, nonlocal)

[x] Class file writer (classwriter.c)
    - JVM class file structure (magic, version, access flags)
    - Fields, methods, and attributes
    - Bootstrap methods attribute for invokedynamic
    - NOTE: StackMapTable attribute needed for code with branches (Java 7+)

[x] Constant pool builder (constpool.c)
    - All constant pool entry types
    - String deduplication
    - Method and field references

[x] invokedynamic infrastructure (indy.h, indy.c)
    - Call site types for Python operations
    - Bootstrap method registration
    - Short runtime class names ($O, $I, $S, etc.) for compact bytecode


IN PROGRESS - Compiler
----------------------

[x] Expression code generation (basic)
    - Literal values (int, float, string, bool, None)
    - Name lookup (local variables)
    - Binary operations via invokedynamic
    - Unary operations via invokedynamic
    - Comparisons via invokedynamic
    - Boolean operators (and, or) with short-circuit
    - Attribute access via invokedynamic
    - Subscript access via invokedynamic
    - Function calls via invokedynamic
    - Collection literals (list, tuple, dict)
    - Conditional expressions (a if test else b)

[x] Statement code generation (basic)
    - Expression statements
    - Assignment (simple and augmented)
    - if/elif/else
    - while loops
    - for loops (iterator protocol)
    - Return statements
    - break/continue
    - pass

[x] Globals and built-ins ($G)
    - Global namespace class
    - Built-in lookup via $G.builtin()
    - Module-level variable storage

[x] Slice objects
    - AST_SLICE codegen creates $SL objects
    - List, tuple, string, bytes all support slicing
    - Forward and reverse slicing with step
    - Slice assignment for lists

[x] Set literals
    - {1, 2, 3} syntax generates $ST.of(Object[])
    - Fixed 'in' operator operand order for containment checks

[x] Comparison chains
    - a < b < c now works (equivalent to (a < b) and (b < c))
    - Intermediate values evaluated only once
    - Short-circuit evaluation on false
    - Works with mixed operators (a < b <= c < d)
    - NOTE: May still require -noverify for complex cases

[x] Method calls
    - Created $BM (bound method) class for method references
    - Added __getattr__ to $S, $L, $D returning bound methods
    - Works with no args: "hello".upper()
    - Works with args: s.replace("a", "b")
    - Works as first-class: m = s.upper; m()

[x] Closures
    - Free variable detection via AST scanning
    - Closure array passed as hidden first parameter
    - $MH.withClosure binds captured values
    - Captured variables accessed via array index
    - Works with multiple captured variables

[x] Comprehensions
    - List comprehensions: [x*2 for x in nums]
    - Set comprehensions: {x*2 for x in nums}
    - Dict comprehensions: {k: v for k, v in items}
    - Filter conditions: [x for x in nums if x > 0]
    - Nested generators: [x for row in matrix for x in row]

[x] Lambda expressions
    - Simple lambdas: lambda x: x + 1
    - Multiple args: lambda x, y: x + y
    - No args: lambda: 42
    - Closures: lambda captures variables from enclosing scope

[x] Generator expressions
    - Simple: (x*2 for x in nums)
    - With filter: (x for x in nums if x > 0)
    - Multiple filters supported
    - Nested generators fallback to eager evaluation via list iterator
    - Lazy evaluation via $GE runtime class

[x] Function definitions
    - Basic function definition and compilation
    - Parameters as local variables
    - Default parameter values (null checking at function entry)
    - *args (vararg) support - receives as tuple parameter
    - **kwargs support - receives as dict parameter
    - Function stored as MethodHandle, called via invokedynamic

[x] Class definitions
    - Basic class: class MyClass: ...
    - __init__ constructor
    - Instance methods with self
    - Instance attributes (self.x)
    - Inheritance: class Child(Parent): ...
    - Method override in subclasses
    - __str__, __repr__ special methods
    - Arithmetic and comparison operators delegation
    - $Cls and $Inst runtime classes

[x] del statement
    - del x (unbind local variable)
    - del d[key] (call __delitem__)
    - del obj.attr (call __delattr__)

[x] assert statement
    - assert condition (raises AssertionError if false)
    - assert condition, message (with custom message)

[x] Exception handling (basic)
    - raise "message" (raise exception)
    - raise exception_obj (raise exception instance)
    - try/except (catch exceptions)
    - Nested try blocks
    - NOTE: Typed except (except TypeError as e:) needs work
    - NOTE: finally runs but doesn't execute on exception path yet

[x] global/nonlocal declarations
    - global x (access/modify global variable from function)
    - Module-level variables automatically stored as globals
    - Module-level functions and classes stored as globals
    - nonlocal x (partially - uses closure mechanism)

[x] with statement (context managers)
    - Basic: with ctx_mgr: body
    - With binding: with ctx_mgr as var: body
    - Calls __enter__ on entry, __exit__ on exit
    - Exception handling with __exit__(type, val, tb)
    - NOTE: Multiple classes per file has issues with globals

[x] Import/module system
    - import module: loads and initializes compiled Python module
    - import module as alias: aliased import
    - from module import name: imports specific attribute
    - from module import name as alias: aliased from-import
    - Module attributes populated from globals after initialization
    - Module caching (imported once, reused)
    - Integrates with Java class loading (each module is a .class file)

[x] StackMapTable generation (improved)
    - Ported from genesis compiler
    - Type tracking for locals and stack
    - Frame recording at branch targets
    - All frame types (same, same_locals_1_stack, chop, append, full)
    - Fixed: Missing stackmap_pop for setGlobal calls
    - Fixed: Missing stackmap tracking for DUP/AASTORE in array building
    - Fixed: Missing stackmap_pop for expression statement POP
    - Fixed: State save/restore for for loop end_label
    - NOTE: Advanced features (walrus operator, with statement, yield) still need work

WORKING - Runtime Library (Java)
--------------------------------

Runtime classes use short $-prefixed names for compact bytecode.
Located in runtime/src/, compiled to runtime/loretta.jar.

Build: cd runtime && make
       Creates loretta.jar with all runtime classes.
       Use: java -cp runtime/loretta.jar:. <classname>

[x] Core types (implemented and tested)
    - $O  (PyObject)   - Base class with all protocol methods
    - $N  (PyNone)     - Singleton None
    - $B  (PyBool)     - Boolean (True, False), extends $I
    - $I  (PyInt)      - Arbitrary precision integer (long + BigInteger)
    - $F  (PyFloat)    - Double-precision float
    - $S  (PyStr)      - Unicode strings with methods + iterator
    - $L  (PyList)     - Mutable sequences + iterator
    - $T  (PyTuple)    - Immutable sequences + iterator
    - $D  (PyDict)     - Dictionaries (insertion-ordered)
    - $X  (PyException)- Runtime exceptions (extends RuntimeException)
    - $MH (PyMethodHandle) - Wrapper for compiled functions
    - $C  (PyComplex)  - Complex numbers
    - $BY (PyBytes)    - Byte sequences + iterator
    - $ST (PySet)      - Mutable sets + iterator
    - $FS (PyFrozenSet) - Immutable sets + iterator
    - $File           - File I/O (for open() builtin)
    - $SL (PySlice)    - Slice objects

[x] Bootstrap methods ($BS) - implemented
    - binop: binary operations (__add__, __sub__, etc.)
    - unaryop: unary operations (__neg__, __pos__, etc.)
    - compare: comparison operations (__lt__, __eq__, etc.)
    - getattr/setattr: attribute access
    - getitem/setitem: subscript access
    - call: function calls (handles $MH and __call__)
    - iter/next: iteration protocol (safeNext catches StopIteration)
    - contains: membership test
    - builtin: bool/len/repr/str/hash conversion

[x] Built-in functions ($G)
    - I/O: print, input, open
    - Types: int, float, str, bool, list, tuple, dict, set, frozenset, bytes, bytearray, complex
    - Type introspection: type, isinstance, issubclass, callable
    - Math: abs, min, max, sum, pow, round, divmod
    - Sequences: len, range, enumerate, zip, map, filter, sorted, reversed, slice
    - Iteration: iter, next
    - Logic: all, any
    - String/char: repr, ord, chr, hex, oct, bin, format, ascii
    - Object: hash, id, getattr, setattr, hasattr, delattr, dir, vars, globals, locals
    - Constants: True, False, None (for direct lookup)
    - Stubs: object (identity constructor)

[x] Tested features (simple programs without complex control flow)
    - Arithmetic: +, -, *, /, //, %
    - Comparisons: <, >, ==
    - Print statements
    - String concatenation and len()
    - List creation, indexing, len()
    - Tuple creation and display
    - Dict creation and display
    - Float arithmetic

[x] Tested features (control flow - StackMapTable fixes applied)
    - If/else branching - works without -noverify
    - While loops - works without -noverify
    - For loops with range - works without -noverify
    - Walrus operator (:=) - works without -noverify
    - 28 of 34 tests pass without -noverify (progress from 27)
    - NOTE: 6 tests need -noverify (assert, chain, except, genexp, with, yield)

[x] Remaining built-in functions (implemented or stubbed)
    - exec, eval, compile (eval supports literals, others raise NotImplementedError)
    - memoryview (full support with $MV class)
    - super (super(cls, obj) for parent class access)
    - staticmethod, classmethod, property (full decorator support)

[ ] Exception types (need proper hierarchy)
    - BaseException, Exception
    - TypeError, ValueError, AttributeError
    - NameError, IndexError, KeyError
    - StopIteration, GeneratorExit


PLANNED - Module System
-----------------------

[ ] Import machinery
    - Module compilation units
    - Package support (__init__.py)
    - Relative imports
    - Import hooks
    - sys.path handling

[ ] Standard library support
    - Pure Python modules (from CPython)
    - Java interop wrappers for common functionality


KNOWN ISSUES
------------

[ ] Module-level for loops
    - For loop target variable not correctly assigned at module level
    - Variables should be stored in globals at module level
    - Workaround: wrap in a function
    - Affects: unpack_test, stmt_test, comp_test, expr_test

[ ] StackMapTable generation
    - Some complex control flow requires -noverify
    - Affects comparison chains, some loops
    - See StackMapTable section for details

[ ] Walrus operator (:=)
    - Parsed but codegen has issues
    - NullPointerException in some cases

[ ] Generator expressions
    - Basic support exists but complex cases fail
    - Nested generators not fully supported

[ ] Multiple classes per file
    - Global variable interactions when multiple classes defined
    - Workaround: one class per file or wrap in functions


FUTURE CONSIDERATIONS
---------------------

[ ] Optimizations
    - Specialized bytecode for common patterns
    - Type inference for local variables
    - Inline caching warmup
    - Dead code elimination

[ ] **IMPORTANT: Native JVM class generation for Python classes**
    Currently all Python classes use runtime $Cls/$Inst objects with dictionary-based
    method lookup. This is flexible (supports multiple inheritance, dynamic modification)
    but slower than native JVM dispatch.
    
    For single-inheritance classes without metaclasses, we could generate actual JVM
    classes where Child extends Parent. This would give:
    - Native JVM method dispatch (significantly faster)
    - JVM JIT optimization of method calls
    - Better integration with Java code
    
    Implementation approach:
    - Detect single-inheritance, no-metaclass classes at compile time
    - Generate a real JVM class (using ClassWriter) for each Python class
    - Map __init__ to constructor, methods to instance methods
    - Instance attributes could use a backing $D or individual fields
    - Fall back to $Cls/$Inst for multiple inheritance or dynamic cases
    
    This is how Jython achieves reasonable performance. Consider prioritizing this
    optimization once the core language features are complete.

[ ] Python compatibility
    - __slots__
    - Metaclasses
    - Descriptors (property, classmethod, staticmethod)
    - Multiple inheritance with C3 MRO
    - __getattr__/__setattr__/__delattr__
    - Context managers (__enter__/__exit__)
    - Iterators and generators
    - Async/await and coroutines

[ ] Java interop
    - Calling Java methods from Python
    - Implementing Java interfaces
    - Java collection wrappers
    - Exception bridging

[ ] Tooling
    - Source maps for debugging
    - REPL
    - Package manager integration

